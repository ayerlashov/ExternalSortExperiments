using BigFileSorter.ExternalMergeSort;
using System.CommandLine;
using System.Diagnostics;

namespace BigFileSorter
{
    public class Program
    {
        const int DefaultMegabyteThreshold = 120;

        public static async Task Main(string[] args)
        {
            Process myProcess = Process.GetCurrentProcess();
            myProcess.PriorityClass = ProcessPriorityClass.High;

            var rootCommand = new RootCommand("An experiment in external sorting. String parts use ordinal sorting.")
            {
                MakeSortCommand(),
                MakeVerifyCommand()
            };

            await rootCommand.InvokeAsync(args);
        }

        private static Command MakeVerifyCommand()
        {
            var sourceFilePathArg = new Argument<FileInfo>("filePath", "The path of the hypothetically sorted file.") { Arity = ArgumentArity.ExactlyOne };

            Command sortCommand = new("verify", "Verifies the sorting of the given file.")
            {
                sourceFilePathArg
            };

            sortCommand.SetHandler(Verify, sourceFilePathArg);

            return sortCommand;
        }

        private static Command MakeSortCommand()
        {
            var sourceFilePathArg = new Argument<FileInfo>("sourceFilePath", "The unsorted file.") { Arity = ArgumentArity.ExactlyOne };
            var tempDirectoryArg = new Argument<DirectoryInfo>("tempFileDirectory", "Where to write temp files.") { Arity = ArgumentArity.ExactlyOne };

            var targetFilePathArg = new Argument<FileInfo>("targetFilePath", "Where to write the sorted file.") { Arity = ArgumentArity.ExactlyOne };
            sourceFilePathArg.ExistingOnly();

            var blockSizeThresholdOpt = new Option<int>("-b", () => DefaultMegabyteThreshold, "How big first pass blocks can be in MB. Must be in range [1, 1000].")
            {
                Arity = ArgumentArity.ExactlyOne
            };

            blockSizeThresholdOpt.AddValidator(option =>
            {
                var val = option.GetValueOrDefault<int>();

                if (val is <1 or >1000)
                {
                    option.ErrorMessage = "Value must be in the range [1, 1000]";
                }
            });

            Command sortCommand = new("sort", "Sorts random files generated by the accompanying test data generator.")
            {
                sourceFilePathArg,
                targetFilePathArg,
                tempDirectoryArg,
                blockSizeThresholdOpt
            };

            sortCommand.SetHandler(
                Sort,
                sourceFilePathArg,
                targetFilePathArg,
                tempDirectoryArg,
                blockSizeThresholdOpt);

            return sortCommand;
        }

        private static void Sort(FileInfo sourceFilePath, FileInfo targetFilePath, DirectoryInfo tempDirectory, int blockSizeThreshold)
        {
            var sw = new Stopwatch();
            Console.WriteLine($"[{DateTime.UtcNow:HH:mm:ss.fff}] Starting.");

            sw.Start();
            new ExternalMergeSorter(tempDirectory.FullName, blockSizeThreshold << 20)
                .Sort(sourceFilePath.FullName, targetFilePath.FullName);
            sw.Stop();
            Console.WriteLine($"[{DateTime.UtcNow:HH:mm:ss.fff}] Completed!");
            Console.WriteLine($"Time taken: {sw.ElapsedMilliseconds/1000.0:0.####}s");
        }

        private static void Verify(FileInfo fileInfo)
        {
            var results = Helpers.Verify(fileInfo.FullName)
                .Take(10)
                .ToList();

            if (results is [(-1, "", "")])
            {
                Console.WriteLine("All good!");
            }
            else
            {
                var message = string.Join(
                    '\n',
                    results.Select(result => result.ToString())
                        .Prepend("Up to first 10 errors: "));
                
                Console.WriteLine(message);
            }
        }
    }
}